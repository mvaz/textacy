
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>textacy.corpus &#8212; textacy 0.6.3 documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for textacy.corpus</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">A class for working with a collection of spaCy docs. Includes functionality for</span>
<span class="sd">easily adding, getting, and removing documents; saving to / loading their data</span>
<span class="sd">from disk; and tracking basic corpus statistics.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">unicode_literals</span>

<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">math</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">spacy</span>
<span class="kn">import</span> <span class="nn">srsly</span>
<span class="kn">from</span> <span class="nn">cytoolz</span> <span class="k">import</span> <span class="n">itertoolz</span>
<span class="kn">from</span> <span class="nn">thinc.neural.ops</span> <span class="k">import</span> <span class="n">NumpyOps</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">cache</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">compat</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">io</span> <span class="k">as</span> <span class="n">tio</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">utils</span>

<span class="n">LOGGER</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<div class="viewcode-block" id="Corpus"><a class="viewcode-back" href="../../api_reference.html#textacy.corpus.Corpus">[docs]</a><span class="k">class</span> <span class="nc">Corpus</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An ordered collection of :class:`spacy.tokens.Doc`, all of the same language</span>
<span class="sd">    and sharing the same :class:`spacy.language.Language` processing pipeline</span>
<span class="sd">    and vocabulary, with data held *in-memory*.</span>

<span class="sd">    Initialize from a language / ``Language`` and (optionally) one or a stream</span>
<span class="sd">    of texts or (text, metadata) pairs:</span>

<span class="sd">    .. code-block:: pycon</span>

<span class="sd">        &gt;&gt;&gt; ds = textacy.datasets.CapitolWords()</span>
<span class="sd">        &gt;&gt;&gt; records = ds.records(limit=50)</span>
<span class="sd">        &gt;&gt;&gt; corpus = textacy.Corpus(&quot;en&quot;, data=records)</span>
<span class="sd">        &gt;&gt;&gt; corpus</span>
<span class="sd">        Corpus(50 docs, 32175 tokens)</span>

<span class="sd">    Add or remove documents, with automatic updating of corpus statistics:</span>

<span class="sd">    .. code-block:: pycon</span>

<span class="sd">        &gt;&gt;&gt; texts = ds.texts(congress=114, limit=25)</span>
<span class="sd">        &gt;&gt;&gt; corpus.add(texts)</span>
<span class="sd">        &gt;&gt;&gt; corpus.add(&quot;If Burton were a member of Congress, here&#39;s what he&#39;d say.&quot;)</span>
<span class="sd">        &gt;&gt;&gt; corpus</span>
<span class="sd">        Corpus(76 docs, 55906 tokens)</span>
<span class="sd">        &gt;&gt;&gt; corpus.remove(lambda doc: doc._.meta.get(&quot;speaker_name&quot;) == &quot;Rick Santorum&quot;)</span>
<span class="sd">        &gt;&gt;&gt; corpus</span>
<span class="sd">        Corpus(61 docs, 48567 tokens)</span>

<span class="sd">    Get subsets of documents matching your particular use case:</span>

<span class="sd">    .. code-block:: pycon</span>

<span class="sd">        &gt;&gt;&gt; match_func = lambda doc: doc._.meta.get(&quot;speaker_name&quot;) == &quot;Bernie Sanders&quot;</span>
<span class="sd">        &gt;&gt;&gt; for doc in corpus.get(match_func, limit=3):</span>
<span class="sd">        ...     print(doc._.preview)</span>
<span class="sd">        Doc(159 tokens: &quot;Mr. Speaker, 480,000 Federal employees are work...&quot;)</span>
<span class="sd">        Doc(336 tokens: &quot;Mr. Speaker, I thank the gentleman for yielding...&quot;)</span>
<span class="sd">        Doc(177 tokens: &quot;Mr. Speaker, if we want to understand why in th...&quot;)</span>

<span class="sd">    Get or remove documents by indexing, too:</span>

<span class="sd">    .. code-block:: pycon</span>

<span class="sd">        &gt;&gt;&gt; corpus[0]._.preview</span>
<span class="sd">        &#39;Doc(159 tokens: &quot;Mr. Speaker, 480,000 Federal employees are work...&quot;)&#39;</span>
<span class="sd">        &gt;&gt;&gt; [doc._.preview for doc in corpus[:3]]</span>
<span class="sd">        [&#39;Doc(159 tokens: &quot;Mr. Speaker, 480,000 Federal employees are work...&quot;)&#39;,</span>
<span class="sd">         &#39;Doc(219 tokens: &quot;Mr. Speaker, a relationship, to work and surviv...&quot;)&#39;,</span>
<span class="sd">         &#39;Doc(336 tokens: &quot;Mr. Speaker, I thank the gentleman for yielding...&quot;)&#39;]</span>
<span class="sd">        &gt;&gt;&gt; del corpus[:5]</span>
<span class="sd">        &gt;&gt;&gt; corpus</span>
<span class="sd">        Corpus(56 docs, 41573 tokens)</span>

<span class="sd">    Compute basic corpus statistics:</span>

<span class="sd">    .. code-block:: pycon</span>

<span class="sd">        &gt;&gt;&gt; corpus.n_docs, corpus.n_sents, corpus.n_tokens</span>
<span class="sd">        (56, 1771, 41573)</span>
<span class="sd">        &gt;&gt;&gt; word_counts = corpus.word_counts(as_strings=True)</span>
<span class="sd">        &gt;&gt;&gt; sorted(word_counts.items(), key=lambda x: x[1], reverse=True)[:5]</span>
<span class="sd">        [(&#39;-PRON-&#39;, 2553), (&#39;people&#39;, 215), (&#39;year&#39;, 148), (&#39;Mr.&#39;, 139), (&#39;$&#39;, 137)]</span>
<span class="sd">        &gt;&gt;&gt; word_doc_counts = corpus.word_doc_counts(weighting=&quot;freq&quot;, as_strings=True)</span>
<span class="sd">        &gt;&gt;&gt; sorted(word_doc_counts.items(), key=lambda x: x[1], reverse=True)[:5]</span>
<span class="sd">        [(&#39;-PRON-&#39;, 0.9821428571428571),</span>
<span class="sd">         (&#39;Mr.&#39;, 0.7678571428571429),</span>
<span class="sd">         (&#39;President&#39;, 0.5),</span>
<span class="sd">         (&#39;people&#39;, 0.48214285714285715),</span>
<span class="sd">         (&#39;need&#39;, 0.44642857142857145)]</span>

<span class="sd">    Save corpus data to and load from disk:</span>

<span class="sd">    .. code-block:: pycon</span>

<span class="sd">        &gt;&gt;&gt; corpus.save(&quot;~/Desktop/capitol_words_sample.bin.gz&quot;)</span>
<span class="sd">        &gt;&gt;&gt; corpus = textacy.Corpus.load(&quot;en&quot;, &quot;~/Desktop/capitol_words_sample.bin.gz&quot;)</span>
<span class="sd">        &gt;&gt;&gt; corpus</span>
<span class="sd">        Corpus(56 docs, 41573 tokens)</span>

<span class="sd">    Args:</span>
<span class="sd">        lang (str or :class:`spacy.language.Language`):</span>
<span class="sd">            Language with which spaCy processes (or processed) all documents</span>
<span class="sd">            added to the corpus, whether as ``data`` now or later.</span>

<span class="sd">            Pass a standard 2-letter language code (e.g. &quot;en&quot;),</span>
<span class="sd">            or the name of a spacy language pipeline (e.g. &quot;en_core_web_md&quot;),</span>
<span class="sd">            or an already-instantiated :class:`spacy.language.Language` object.</span>

<span class="sd">            A given / detected language string is then used to instantiate</span>
<span class="sd">            a corresponding ``Language`` with all default components enabled.</span>
<span class="sd">        data (obj or Iterable[obj]): One or a stream of texts, records,</span>
<span class="sd">            or :class:`spacy.tokens.Doc` s to be added to the corpus.</span>

<span class="sd">            .. seealso:: :meth:`Corpus.add()`</span>

<span class="sd">    Attributes:</span>
<span class="sd">        lang (str)</span>
<span class="sd">        spacy_lang (:class:`spacy.language.Language`)</span>
<span class="sd">        docs (List[:class:`spacy.tokens.Doc`])</span>
<span class="sd">        n_docs (int)</span>
<span class="sd">        n_sents (int)</span>
<span class="sd">        n_tokens (int)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lang</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spacy_lang</span> <span class="o">=</span> <span class="n">_get_spacy_lang</span><span class="p">(</span><span class="n">lang</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lang</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spacy_lang</span><span class="o">.</span><span class="n">lang</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">docs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_doc_ids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_docs</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_sents</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_tokens</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">data</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="c1"># dunder</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;Corpus(</span><span class="si">{}</span><span class="s2"> docs, </span><span class="si">{}</span><span class="s2"> tokens)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_docs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_tokens</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_docs</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">docs</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">doc</span>

    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">doc</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">id</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_doc_ids</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx_or_slice</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">docs</span><span class="p">[</span><span class="n">idx_or_slice</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx_or_slice</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx_or_slice</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_remove_one_doc_by_index</span><span class="p">(</span><span class="n">idx_or_slice</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx_or_slice</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">step</span> <span class="o">=</span> <span class="n">idx_or_slice</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_docs</span><span class="p">)</span>
            <span class="n">idxs</span> <span class="o">=</span> <span class="n">compat</span><span class="o">.</span><span class="n">range_</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_remove_many_docs_by_index</span><span class="p">(</span><span class="n">idxs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;list indices must be integers or slices, not </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">idx_or_slice</span><span class="p">))</span>
            <span class="p">)</span>

    <span class="c1"># add documents</span>

<div class="viewcode-block" id="Corpus.add"><a class="viewcode-back" href="../../api_reference.html#textacy.corpus.Corpus.add">[docs]</a>    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add one or a stream of texts, records, or :class:`spacy.tokens.Doc` s</span>
<span class="sd">        to the corpus, ensuring that all processing is or has already been done</span>
<span class="sd">        by the :attr:`Corpus.spacy_lang` pipeline.</span>

<span class="sd">        Args:</span>
<span class="sd">            data (obj or Iterable[obj]):</span>
<span class="sd">                str or Iterable[str]</span>
<span class="sd">                Tuple[str, dict] or Iterable[Tuple[str, dict]]</span>
<span class="sd">                :class:`spacy.tokens.Doc` or Iterable[:class:`spacy.tokens.Doc`]</span>
<span class="sd">            batch_size (int)</span>

<span class="sd">        See Also:</span>
<span class="sd">            * :meth:`Corpus.add_text()`</span>
<span class="sd">            * :meth:`Corpus.add_texts()`</span>
<span class="sd">            * :meth:`Corpus.add_record()`</span>
<span class="sd">            * :meth:`Corpus.add_records()`</span>
<span class="sd">            * :meth:`Corpus.add_doc()`</span>
<span class="sd">            * :meth:`Corpus.add_docs()`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">compat</span><span class="o">.</span><span class="n">unicode_</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_text</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">spacy</span><span class="o">.</span><span class="n">tokens</span><span class="o">.</span><span class="n">Doc</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_doc</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_record</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_record</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">compat</span><span class="o">.</span><span class="n">Iterable</span><span class="p">):</span>
            <span class="n">first</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="n">itertoolz</span><span class="o">.</span><span class="n">peek</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">compat</span><span class="o">.</span><span class="n">unicode_</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_texts</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">spacy</span><span class="o">.</span><span class="n">tokens</span><span class="o">.</span><span class="n">Doc</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_docs</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_record</span><span class="p">(</span><span class="n">first</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_records</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;data must be one of </span><span class="si">{}</span><span class="s2"> or an interable thereof, not </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="p">{</span><span class="n">compat</span><span class="o">.</span><span class="n">unicode_</span><span class="p">,</span> <span class="n">spacy</span><span class="o">.</span><span class="n">tokens</span><span class="o">.</span><span class="n">Doc</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">},</span>
                        <span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">),</span>
                    <span class="p">)</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;data must be one of </span><span class="si">{}</span><span class="s2"> or an interable thereof, not </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="p">{</span><span class="n">compat</span><span class="o">.</span><span class="n">unicode_</span><span class="p">,</span> <span class="n">spacy</span><span class="o">.</span><span class="n">tokens</span><span class="o">.</span><span class="n">Doc</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">},</span>
                    <span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="p">)</span></div>

<div class="viewcode-block" id="Corpus.add_text"><a class="viewcode-back" href="../../api_reference.html#textacy.corpus.Corpus.add_text">[docs]</a>    <span class="k">def</span> <span class="nf">add_text</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add one text to the corpus, processing it into a :class:`spacy.tokens.Doc`</span>
<span class="sd">        using the :attr:`Corpus.spacy_lang` pipeline.</span>

<span class="sd">        Args:</span>
<span class="sd">            text (str)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_add_valid_doc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spacy_lang</span><span class="p">(</span><span class="n">text</span><span class="p">))</span></div>

<div class="viewcode-block" id="Corpus.add_texts"><a class="viewcode-back" href="../../api_reference.html#textacy.corpus.Corpus.add_texts">[docs]</a>    <span class="k">def</span> <span class="nf">add_texts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">texts</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a stream of texts to the corpus, efficiently processing them into</span>
<span class="sd">        :class:`spacy.tokens.Doc` s using the :attr:`Corpus.spacy_lang` pipeline.</span>

<span class="sd">        Args:</span>
<span class="sd">            texts (Iterable[str])</span>
<span class="sd">            batch_size (int)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spacy_lang</span><span class="o">.</span><span class="n">pipe</span><span class="p">(</span><span class="n">texts</span><span class="p">,</span> <span class="n">as_tuples</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_add_valid_doc</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span></div>

<div class="viewcode-block" id="Corpus.add_record"><a class="viewcode-back" href="../../api_reference.html#textacy.corpus.Corpus.add_record">[docs]</a>    <span class="k">def</span> <span class="nf">add_record</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add one record to the corpus, processing it into a :class:`spacy.tokens.Doc`</span>
<span class="sd">        using the :attr:`Corpus.spacy_lang` pipeline.</span>

<span class="sd">        Args:</span>
<span class="sd">            record (Tuple[str, dict])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">doc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spacy_lang</span><span class="p">(</span><span class="n">record</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">doc</span><span class="o">.</span><span class="n">_</span><span class="o">.</span><span class="n">meta</span> <span class="o">=</span> <span class="n">record</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_add_valid_doc</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span></div>

<div class="viewcode-block" id="Corpus.add_records"><a class="viewcode-back" href="../../api_reference.html#textacy.corpus.Corpus.add_records">[docs]</a>    <span class="k">def</span> <span class="nf">add_records</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">records</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a stream of records to the corpus, efficiently processing them into</span>
<span class="sd">        :class:`spacy.tokens.Doc` s using the :attr:`Corpus.spacy_lang` pipeline.</span>

<span class="sd">        Args:</span>
<span class="sd">            records (Iterable[Tuple[str, dict]])</span>
<span class="sd">            batch_size (int)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">doc</span><span class="p">,</span> <span class="n">meta</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spacy_lang</span><span class="o">.</span><span class="n">pipe</span><span class="p">(</span><span class="n">records</span><span class="p">,</span> <span class="n">as_tuples</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">):</span>
            <span class="n">doc</span><span class="o">.</span><span class="n">_</span><span class="o">.</span><span class="n">meta</span> <span class="o">=</span> <span class="n">meta</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_add_valid_doc</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span></div>

<div class="viewcode-block" id="Corpus.add_doc"><a class="viewcode-back" href="../../api_reference.html#textacy.corpus.Corpus.add_doc">[docs]</a>    <span class="k">def</span> <span class="nf">add_doc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">doc</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add one :class:`spacy.tokens.Doc` to the corpus, provided it was processed</span>
<span class="sd">        using the :attr:`Corpus.spacy_lang` pipeline.</span>

<span class="sd">        Args:</span>
<span class="sd">            doc (:class:`spacy.tokens.Doc`)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="n">spacy</span><span class="o">.</span><span class="n">tokens</span><span class="o">.</span><span class="n">Doc</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;doc must be a </span><span class="si">{}</span><span class="s2">, not </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spacy</span><span class="o">.</span><span class="n">tokens</span><span class="o">.</span><span class="n">Doc</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">doc</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">doc</span><span class="o">.</span><span class="n">vocab</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">spacy_lang</span><span class="o">.</span><span class="n">vocab</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;doc.vocab (</span><span class="si">{}</span><span class="s2">) must be the same as corpus.vocab (</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">doc</span><span class="o">.</span><span class="n">vocab</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spacy_lang</span><span class="o">.</span><span class="n">vocab</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_add_valid_doc</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span></div>

<div class="viewcode-block" id="Corpus.add_docs"><a class="viewcode-back" href="../../api_reference.html#textacy.corpus.Corpus.add_docs">[docs]</a>    <span class="k">def</span> <span class="nf">add_docs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">docs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a stream of :class:`spacy.tokens.Doc` s to the corpus, provided</span>
<span class="sd">        they were processed using the :attr:`Corpus.spacy_lang` pipeline.</span>

<span class="sd">        Args:</span>
<span class="sd">            doc (Iterable[:class:`spacy.tokens.Doc`])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="n">docs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_doc</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_add_valid_doc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">doc</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">docs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_doc_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">doc</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_docs</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_tokens</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">doc</span><span class="o">.</span><span class="n">is_sentenced</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_sents</span> <span class="o">+=</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">doc</span><span class="o">.</span><span class="n">sents</span><span class="p">)</span>

    <span class="c1"># get documents</span>

<div class="viewcode-block" id="Corpus.get"><a class="viewcode-back" href="../../api_reference.html#textacy.corpus.Corpus.get">[docs]</a>    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">match_func</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get all (or N &lt;= ``limit``) docs in :class:`Corpus` for which</span>
<span class="sd">        ``match_func(doc)`` is True.</span>

<span class="sd">        Args:</span>
<span class="sd">            match_func (Callable): Function that takes a :class:`spacy.tokens.Doc`</span>
<span class="sd">                as input and returns a boolean value. For example::</span>

<span class="sd">                    Corpus.get(lambda x: len(x) &gt;= 100)</span>

<span class="sd">                gets all docs with at least 100 tokens. And::</span>

<span class="sd">                    Corpus.get(lambda doc: doc._.meta[&quot;author&quot;] == &quot;Burton DeWilde&quot;)</span>

<span class="sd">                gets all docs whose author was given as &#39;Burton DeWilde&#39;.</span>
<span class="sd">            limit (int): Maximum number of matched docs to return.</span>

<span class="sd">        Yields:</span>
<span class="sd">            :class:`spacy.tokens.Doc`: Next document passing ``match_func``.</span>

<span class="sd">        See Also:</span>
<span class="sd">            :meth:`Corpus.remove()`</span>

<span class="sd">        .. tip:: To get doc(s) by index, treat :class:`Corpus` as a list and use</span>
<span class="sd">           Python&#39;s usual indexing and slicing: ``Corpus[0]`` gets the first</span>
<span class="sd">           document in the corpus; ``Corpus[:5]`` gets the first 5; etc.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">matched_docs</span> <span class="o">=</span> <span class="p">(</span><span class="n">doc</span> <span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">match_func</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">islice</span><span class="p">(</span><span class="n">matched_docs</span><span class="p">,</span> <span class="n">limit</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">doc</span></div>

    <span class="c1"># remove documents</span>

<div class="viewcode-block" id="Corpus.remove"><a class="viewcode-back" href="../../api_reference.html#textacy.corpus.Corpus.remove">[docs]</a>    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">match_func</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove all (or N &lt;= ``limit``) docs in :class:`Corpus` for which</span>
<span class="sd">        ``match_func(doc)`` is True. Corpus doc/sent/token counts are adjusted</span>
<span class="sd">        accordingly.</span>

<span class="sd">        Args:</span>
<span class="sd">            match_func (func): Function that takes a :class:`spacy.tokens.Doc`</span>
<span class="sd">                and returns a boolean value. For example::</span>

<span class="sd">                    Corpus.remove(lambda x: len(x) &gt;= 100)</span>

<span class="sd">                removes docs with at least 100 tokens. And::</span>

<span class="sd">                    Corpus.remove(lambda doc: doc._.meta[&quot;author&quot;] == &quot;Burton DeWilde&quot;)</span>

<span class="sd">                removes docs whose author was given as &quot;Burton DeWilde&quot;.</span>
<span class="sd">            limit (int): Maximum number of matched docs to remove.</span>

<span class="sd">        See Also:</span>
<span class="sd">            :meth:`Corpus.get()`</span>

<span class="sd">        .. tip:: To remove doc(s) by index, treat :class:`Corpus` as a list and use</span>
<span class="sd">           Python&#39;s usual indexing and slicing: ``del Corpus[0]`` removes the</span>
<span class="sd">           first document in the corpus; ``del Corpus[:5]`` removes the first</span>
<span class="sd">           5; etc.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">matched_docs</span> <span class="o">=</span> <span class="p">(</span><span class="n">doc</span> <span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">match_func</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_remove_many_docs_by_index</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_doc_ids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">doc</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">islice</span><span class="p">(</span><span class="n">matched_docs</span><span class="p">,</span> <span class="n">limit</span><span class="p">)</span>
        <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_remove_many_docs_by_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idxs</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">idxs</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_remove_one_doc_by_index</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_remove_one_doc_by_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="n">doc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">docs</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_docs</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_tokens</span> <span class="o">-=</span> <span class="nb">len</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">doc</span><span class="o">.</span><span class="n">is_sentenced</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_sents</span> <span class="o">-=</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">doc</span><span class="o">.</span><span class="n">sents</span><span class="p">)</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">docs</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_doc_ids</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

    <span class="c1"># useful properties</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">vectors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Constituent docs&#39; word vectors stacked in a 2d array.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">doc</span><span class="o">.</span><span class="n">vector</span> <span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">vector_norms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Constituent docs&#39; L2-normalized word vectors stacked in a 2d array.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">doc</span><span class="o">.</span><span class="n">vector_norm</span> <span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">))</span>

    <span class="c1"># useful methods</span>

<div class="viewcode-block" id="Corpus.word_counts"><a class="viewcode-back" href="../../api_reference.html#textacy.corpus.Corpus.word_counts">[docs]</a>    <span class="k">def</span> <span class="nf">word_counts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="s2">&quot;lemma&quot;</span><span class="p">,</span> <span class="n">weighting</span><span class="o">=</span><span class="s2">&quot;count&quot;</span><span class="p">,</span> <span class="n">as_strings</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Map the set of unique words in :class:`Corpus` to their counts as</span>
<span class="sd">        absolute, relative, or binary frequencies of occurence,</span>
<span class="sd">        similar to :meth:`Doc._.to_bag_of_words()` but aggregated over all docs.</span>

<span class="sd">        Args:</span>
<span class="sd">            normalize (str): If &quot;lemma&quot;, lemmatize words before counting; if</span>
<span class="sd">                &quot;lower&quot;, lowercase words before counting; otherwise, words are</span>
<span class="sd">                counted using the form with which they appear.</span>
<span class="sd">            weighting ({&quot;count&quot;, &quot;freq&quot;}): Type of weight to assign to words.</span>
<span class="sd">                If &quot;count&quot; (default), weights are the absolute number of</span>
<span class="sd">                occurrences (count) of word in corpus.</span>
<span class="sd">                If &quot;freq&quot;, word counts are normalized by the total token count,</span>
<span class="sd">                giving their relative frequencies of occurrence.</span>

<span class="sd">                .. note:: The resulting set of frequencies won&#39;t (necessarily) sum</span>
<span class="sd">                   to 1.0, since punctuation and stop words are filtered out after</span>
<span class="sd">                   counts are normalized.</span>

<span class="sd">            as_strings (bool): If True, words are returned as strings; if False</span>
<span class="sd">                (default), words are returned as their unique integer ids.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: mapping of a unique word id or string (depending on the value</span>
<span class="sd">            of ``as_strings``) to its absolute, relative, or binary frequency</span>
<span class="sd">            of occurrence (depending on the value of ``weighting``).</span>

<span class="sd">        See Also:</span>
<span class="sd">            :func:`textacy.vsm.get_term_freqs()`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">word_counts_</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">word_counts_</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                <span class="n">doc</span><span class="o">.</span><span class="n">_</span><span class="o">.</span><span class="n">to_bag_of_words</span><span class="p">(</span>
                    <span class="n">normalize</span><span class="o">=</span><span class="n">normalize</span><span class="p">,</span> <span class="n">weighting</span><span class="o">=</span><span class="s2">&quot;count&quot;</span><span class="p">,</span> <span class="n">as_strings</span><span class="o">=</span><span class="n">as_strings</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">weighting</span> <span class="o">==</span> <span class="s2">&quot;count&quot;</span><span class="p">:</span>
            <span class="n">word_counts_</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">word_counts_</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">weighting</span> <span class="o">==</span> <span class="s2">&quot;freq&quot;</span><span class="p">:</span>
            <span class="n">n_tokens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_tokens</span>
            <span class="n">word_counts_</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">word</span><span class="p">:</span> <span class="n">count</span> <span class="o">/</span> <span class="n">n_tokens</span> <span class="k">for</span> <span class="n">word</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">word_counts_</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;weighting=&#39;</span><span class="si">{}</span><span class="s2">&#39; is invalid; valid values are </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">weighting</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;count&quot;</span><span class="p">,</span> <span class="s2">&quot;freq&quot;</span><span class="p">}</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">word_counts_</span></div>

<div class="viewcode-block" id="Corpus.word_doc_counts"><a class="viewcode-back" href="../../api_reference.html#textacy.corpus.Corpus.word_doc_counts">[docs]</a>    <span class="k">def</span> <span class="nf">word_doc_counts</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="s2">&quot;lemma&quot;</span><span class="p">,</span> <span class="n">weighting</span><span class="o">=</span><span class="s2">&quot;count&quot;</span><span class="p">,</span> <span class="n">smooth_idf</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">as_strings</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Map the set of unique words in :class:`Corpus` to their *document* counts</span>
<span class="sd">        as absolute, relative, inverse, or binary frequencies of occurence.</span>

<span class="sd">        Args:</span>
<span class="sd">            normalize (str): If &quot;lemma&quot;, lemmatize words before counting; if</span>
<span class="sd">                &quot;lower&quot;, lowercase words before counting; otherwise, words are</span>
<span class="sd">                counted using the form with which they appear.</span>
<span class="sd">            weighting ({&quot;count&quot;, &quot;freq&quot;, &quot;idf&quot;}): Type of weight to assign to words.</span>
<span class="sd">                If &quot;count&quot; (default), weights are the absolute number (count)</span>
<span class="sd">                of documents in which word appears. If &quot;freq&quot;, word doc counts</span>
<span class="sd">                are normalized by the total document count, giving their relative</span>
<span class="sd">                frequencies of occurrence. If &quot;idf&quot;, weights are the log of the</span>
<span class="sd">                inverse relative frequencies: ``log(n_docs / word_doc_count)``</span>
<span class="sd">                or (if ``smooth_idf`` is True) ``log(1 + (n_docs / word_doc_count))`` .</span>
<span class="sd">            smooth_idf (bool): If True, add 1 to all word doc counts when</span>
<span class="sd">                calculating &quot;idf&quot; weighting, equivalent to adding a single</span>
<span class="sd">                document to the corpus containing every unique word.</span>
<span class="sd">            as_strings (bool): If True, words are returned as strings; if False</span>
<span class="sd">                (default), words are returned as their unique integer ids</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: mapping of a unique word id or string (depending on the value</span>
<span class="sd">            of ``as_strings``) to the number of documents in which it appears</span>
<span class="sd">            weighted as absolute, relative, or binary frequencies (depending</span>
<span class="sd">            on the value of ``weighting``).</span>

<span class="sd">        See Also:</span>
<span class="sd">            :func:`textacy.vsm.get_doc_freqs()`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">word_doc_counts_</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">word_doc_counts_</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                <span class="n">doc</span><span class="o">.</span><span class="n">_</span><span class="o">.</span><span class="n">to_bag_of_words</span><span class="p">(</span>
                    <span class="n">normalize</span><span class="o">=</span><span class="n">normalize</span><span class="p">,</span> <span class="n">weighting</span><span class="o">=</span><span class="s2">&quot;binary&quot;</span><span class="p">,</span> <span class="n">as_strings</span><span class="o">=</span><span class="n">as_strings</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">weighting</span> <span class="o">==</span> <span class="s2">&quot;count&quot;</span><span class="p">:</span>
            <span class="n">word_doc_counts_</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">word_doc_counts_</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">weighting</span> <span class="o">==</span> <span class="s2">&quot;freq&quot;</span><span class="p">:</span>
            <span class="n">n_docs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_docs</span>
            <span class="n">word_doc_counts_</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">word</span><span class="p">:</span> <span class="n">count</span> <span class="o">/</span> <span class="n">n_docs</span> <span class="k">for</span> <span class="n">word</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">word_doc_counts_</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">}</span>
        <span class="k">elif</span> <span class="n">weighting</span> <span class="o">==</span> <span class="s2">&quot;idf&quot;</span><span class="p">:</span>
            <span class="n">n_docs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_docs</span>
            <span class="k">if</span> <span class="n">smooth_idf</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">word_doc_counts_</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="n">word</span><span class="p">:</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">n_docs</span> <span class="o">/</span> <span class="n">count</span><span class="p">))</span>
                    <span class="k">for</span> <span class="n">word</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">word_doc_counts_</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="p">}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">word_doc_counts_</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="n">word</span><span class="p">:</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">n_docs</span> <span class="o">/</span> <span class="n">count</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">word</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">word_doc_counts_</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;weighting=&#39;</span><span class="si">{}</span><span class="s2">&#39; is invalid; valid values are </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">weighting</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;count&quot;</span><span class="p">,</span> <span class="s2">&quot;freq&quot;</span><span class="p">,</span> <span class="s2">&quot;idf&quot;</span><span class="p">}</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">word_doc_counts_</span></div>

    <span class="c1"># file io</span>

<div class="viewcode-block" id="Corpus.save"><a class="viewcode-back" href="../../api_reference.html#textacy.corpus.Corpus.save">[docs]</a>    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filepath</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save :class:`Corpus` to disk as binary data.</span>

<span class="sd">        Args:</span>
<span class="sd">            filepath (str): Full path to file on disk where :class:`Corpus` data</span>
<span class="sd">                will be saved as a binary file.</span>

<span class="sd">        See Also:</span>
<span class="sd">            :meth:`Corpus.load()`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">spacy</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">ORTH</span><span class="p">,</span>
            <span class="n">spacy</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">SPACY</span><span class="p">,</span>
            <span class="n">spacy</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">LEMMA</span><span class="p">,</span>
            <span class="n">spacy</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">ENT_IOB</span><span class="p">,</span>
            <span class="n">spacy</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">ENT_TYPE</span><span class="p">,</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_tagged</span><span class="p">:</span>
            <span class="n">attrs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spacy</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">TAG</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_parsed</span><span class="p">:</span>
            <span class="n">attrs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spacy</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">HEAD</span><span class="p">)</span>
            <span class="n">attrs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spacy</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">DEP</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">attrs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spacy</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">SENT_START</span><span class="p">)</span>

        <span class="n">tokens</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">lengths</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">strings</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">user_datas</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">tokens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">doc</span><span class="o">.</span><span class="n">to_array</span><span class="p">(</span><span class="n">attrs</span><span class="p">))</span>
            <span class="n">lengths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">doc</span><span class="p">))</span>
            <span class="n">strings</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">tok</span><span class="o">.</span><span class="n">text</span> <span class="k">for</span> <span class="n">tok</span> <span class="ow">in</span> <span class="n">doc</span><span class="p">)</span>
            <span class="n">user_datas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">doc</span><span class="o">.</span><span class="n">user_data</span><span class="p">)</span>

        <span class="n">msg</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;meta&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">spacy_lang</span><span class="o">.</span><span class="n">meta</span><span class="p">,</span>
            <span class="s2">&quot;attrs&quot;</span><span class="p">:</span> <span class="n">attrs</span><span class="p">,</span>
            <span class="s2">&quot;tokens&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span><span class="o">.</span><span class="n">tobytes</span><span class="p">(</span><span class="s2">&quot;C&quot;</span><span class="p">),</span>
            <span class="s2">&quot;lengths&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">lengths</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int32&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">tobytes</span><span class="p">(</span><span class="s2">&quot;C&quot;</span><span class="p">),</span>
            <span class="s2">&quot;strings&quot;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">strings</span><span class="p">),</span>
            <span class="s2">&quot;user_datas&quot;</span><span class="p">:</span> <span class="n">user_datas</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">with</span> <span class="n">tio</span><span class="o">.</span><span class="n">open_sesame</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">srsly</span><span class="o">.</span><span class="n">msgpack_dumps</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span></div>

<div class="viewcode-block" id="Corpus.load"><a class="viewcode-back" href="../../api_reference.html#textacy.corpus.Corpus.load">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">lang</span><span class="p">,</span> <span class="n">filepath</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load previously saved :class:`Corpus` binary data, reproduce the original</span>
<span class="sd">        `:class:`spacy.tokens.Doc`s tokens and annotations, and instantiate</span>
<span class="sd">        a new :class:`Corpus` from them.</span>

<span class="sd">        Args:</span>
<span class="sd">            lang (str or :class:`spacy.language.Language`)</span>
<span class="sd">            filepath (str): Full path to file on disk where :class:`Corpus` data</span>
<span class="sd">                was previously saved as a binary file.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :class:`Corpus`</span>

<span class="sd">        See Also:</span>
<span class="sd">            :meth:`Corpus.save()`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">spacy_lang</span> <span class="o">=</span> <span class="n">_get_spacy_lang</span><span class="p">(</span><span class="n">lang</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">tio</span><span class="o">.</span><span class="n">open_sesame</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="n">srsly</span><span class="o">.</span><span class="n">msgpack_loads</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">spacy_lang</span><span class="o">.</span><span class="n">meta</span> <span class="o">!=</span> <span class="n">msg</span><span class="p">[</span><span class="s2">&quot;meta&quot;</span><span class="p">]:</span>
            <span class="n">LOGGER</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;the spacy langs are different!&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">string</span> <span class="ow">in</span> <span class="n">msg</span><span class="p">[</span><span class="s2">&quot;strings&quot;</span><span class="p">]:</span>
            <span class="n">spacy_lang</span><span class="o">.</span><span class="n">vocab</span><span class="p">[</span><span class="n">string</span><span class="p">]</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="n">msg</span><span class="p">[</span><span class="s2">&quot;attrs&quot;</span><span class="p">]</span>
        <span class="n">lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">msg</span><span class="p">[</span><span class="s2">&quot;lengths&quot;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int32&quot;</span><span class="p">)</span>
        <span class="n">flat_tokens</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">msg</span><span class="p">[</span><span class="s2">&quot;tokens&quot;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;uint64&quot;</span><span class="p">)</span>
        <span class="n">flat_tokens</span> <span class="o">=</span> <span class="n">flat_tokens</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="p">(</span><span class="n">flat_tokens</span><span class="o">.</span><span class="n">size</span> <span class="o">//</span> <span class="nb">len</span><span class="p">(</span><span class="n">attrs</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">attrs</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">NumpyOps</span><span class="p">()</span><span class="o">.</span><span class="n">unflatten</span><span class="p">(</span><span class="n">flat_tokens</span><span class="p">,</span> <span class="n">lengths</span><span class="p">))</span>
        <span class="n">user_datas</span> <span class="o">=</span> <span class="n">msg</span><span class="p">[</span><span class="s2">&quot;user_datas&quot;</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">_make_spacy_docs</span><span class="p">(</span><span class="n">tokens</span><span class="p">,</span> <span class="n">user_datas</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">toks</span><span class="p">,</span> <span class="n">user_data</span> <span class="ow">in</span> <span class="n">compat</span><span class="o">.</span><span class="n">zip_</span><span class="p">(</span><span class="n">tokens</span><span class="p">,</span> <span class="n">user_datas</span><span class="p">):</span>
                <span class="n">doc</span> <span class="o">=</span> <span class="n">spacy</span><span class="o">.</span><span class="n">tokens</span><span class="o">.</span><span class="n">Doc</span><span class="p">(</span>
                    <span class="n">spacy_lang</span><span class="o">.</span><span class="n">vocab</span><span class="p">,</span>
                    <span class="n">words</span><span class="o">=</span><span class="p">[</span><span class="n">spacy_lang</span><span class="o">.</span><span class="n">vocab</span><span class="o">.</span><span class="n">strings</span><span class="p">[</span><span class="n">orth</span><span class="p">]</span> <span class="k">for</span> <span class="n">orth</span> <span class="ow">in</span> <span class="n">toks</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]],</span>
                    <span class="n">spaces</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="o">.</span><span class="n">tolist</span><span class="p">(</span><span class="n">toks</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]),</span>
                <span class="p">)</span>
                <span class="n">doc</span> <span class="o">=</span> <span class="n">doc</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">attrs</span><span class="p">[</span><span class="mi">2</span><span class="p">:],</span> <span class="n">toks</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:])</span>
                <span class="n">doc</span><span class="o">.</span><span class="n">user_data</span> <span class="o">=</span> <span class="n">user_data</span>
                <span class="k">yield</span> <span class="n">doc</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">spacy_lang</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">_make_spacy_docs</span><span class="p">(</span><span class="n">tokens</span><span class="p">,</span> <span class="n">user_datas</span><span class="p">))</span></div></div>


<span class="k">def</span> <span class="nf">_get_spacy_lang</span><span class="p">(</span><span class="n">lang</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lang</span><span class="p">,</span> <span class="n">compat</span><span class="o">.</span><span class="n">unicode_</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cache</span><span class="o">.</span><span class="n">load_spacy_lang</span><span class="p">(</span><span class="n">lang</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lang</span><span class="p">,</span> <span class="n">spacy</span><span class="o">.</span><span class="n">language</span><span class="o">.</span><span class="n">Language</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">lang</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;`lang` must be </span><span class="si">{}</span><span class="s2">, not </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="p">{</span><span class="n">compat</span><span class="o">.</span><span class="n">unicode_</span><span class="p">,</span> <span class="n">spacy</span><span class="o">.</span><span class="n">language</span><span class="o">.</span><span class="n">Language</span><span class="p">},</span> <span class="nb">type</span><span class="p">(</span><span class="n">lang</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>
</pre></div>

          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">textacy</a></h1>






<p>
<iframe src="https://ghbtns.com/github-btn.html?user=chartbeat-labs&repo=textacy&type=watch&count=False&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started/quickstart.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api_reference.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../license.html">License</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019 Chartbeat, Inc.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.0.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>